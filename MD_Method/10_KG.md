# **Final KG Design: Complete Framework for Energy Complementarity with Deployment Optimization**

## **1. Core Node Architecture**

### **1.1 Physical Infrastructure Nodes**

```markdown
┌─────────────────────────────────────────┐
│ Building (Complete)                      │
├─────────────────────────────────────────┤
│ Static Attributes:                       │
│ - ogc_fid: unique identifier            │
│ - building_function: residential/commercial │
│ - residential_type: detached/semi/terrace/apartment │
│ - non_residential_type: office/retail/industrial/healthcare │
│ - area: floor area (m²)                 │
│ - height: building height (m)           │
│ - age_range: <1945/1945-75/75-95/95-15/>2015 │
│ - building_orientation_cardinal: N/S/E/W/NE/SE/SW/NW/Flat │
│                                          │
│ Energy Characteristics:                  │
│ - energy_label: A/B/C/D/E/F/G/Unknown   │
│   (derived from age + type if unknown)  │
│ - insulation_quality: poor/fair/good/excellent │
│   (inferred from age + label)           │
│                                          │
│ Roof Characteristics:                    │
│ - roof_area: total roof (m²)            │
│ - flat_roof_area: flat portion (m²)     │
│ - sloped_roof_area: sloped portion (m²) │
│ - suitable_roof_area: usable for solar (m²) │
│   (calculated: flat + south-facing sloped) │
│                                          │
│ Current Energy Assets:                   │
│ - has_solar: boolean                    │
│ - has_battery: boolean                  │
│ - has_heat_pump: boolean                │
│ - heating_system: gas/electric/district/unknown │
│ - cooling_system: none/AC/heat_pump     │
│                                          │
│ Deployment Potential:                    │
│ - solar_potential: high/medium/low/none │
│ - battery_readiness: ready/conditional/not_suitable │
│ - electrification_feasibility: immediate/upgrade_needed/not_feasible │
│                                          │
│ Grid Connection:                         │
│ - connection_capacity: Amps (3x25, 3x35, etc.) │
│ - lv_component_id: reference to LV network │
│ - distance_to_transformer: meters       │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ LV_Network                               │
├─────────────────────────────────────────┤
│ - component_id: unique network ID       │
│ - transformer_capacity_kva: 250/400/630 │
│ - connected_buildings: count            │
│ - current_peak_load: kW                 │
│ - available_capacity: kW                │
│ - diversity_index: 0-1                  │
│   (mix of building types)               │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ MV_Transformer                           │
├─────────────────────────────────────────┤
│ - transformer_id: unique ID             │
│ - capacity_mva: rating                  │
│ - connected_lv_networks: count          │
│ - substation_id: upstream reference     │
└─────────────────────────────────────────┘
```

### **1.2 Energy Asset Nodes**

```markdown
┌─────────────────────────────────────────┐
│ SolarSystem                              │
├─────────────────────────────────────────┤
│ - system_id: unique identifier          │
│ - building_id: owner reference          │
│ - status: existing/planned/potential    │
│ - installed_capacity_kwp: actual if exists │
│ - potential_capacity_kwp: calculated max │
│ - recommended_capacity_kwp: optimal size │
│ - installation_year: if existing        │
│ - degradation_factor: 0.98^years        │
│ - orientation_efficiency: 0.6-1.0       │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ BatterySystem                            │
├─────────────────────────────────────────┤
│ - system_id: unique identifier          │
│ - building_id: owner reference          │
│ - status: existing/planned/potential    │
│ - installed_capacity_kwh: if exists     │
│ - recommended_capacity_kwh: optimal     │
│   (2-4 hours of average evening demand) │
│ - power_rating_kw: charge/discharge rate │
│ - round_trip_efficiency: 0.85-0.95      │
└─────────────────────────────────────────┘


```

### **1.3 Temporal & State Nodes**

```markdown
┌─────────────────────────────────────────┐
│ TimeSlot                                 │
├─────────────────────────────────────────┤
│ - slot_id: unique identifier            │
│ - timestamp: datetime                   │
│ - hour_of_day: 0-23                    │
│ - day_of_week: 1-7                     │
│ - is_weekend: boolean                   │
│ - season: winter/spring/summer/fall     │
│ - weather_condition: clear/cloudy/rain  │
│ - temperature: degrees Celsius          │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ EnergyState                              │
├─────────────────────────────────────────┤
│ - state_id: unique identifier           │
│ - building_id: reference                │
│ - timeslot_id: reference                │
│                                          │
│ Current Demands (from simulation):      │
│ - electricity_demand_kw: base electric  │
│ - heating_demand_kw: thermal need       │
│ - cooling_demand_kw: cooling need       │
│                                          │
│ Assumed Current Supply:                 │
│ - grid_import_kw: from network          │
│ - gas_consumption_m3: if gas heating    │
│ - solar_generation_kw: if has solar     │
│ - battery_discharge_kw: if has battery  │
│                                          │
│ Electrification Scenario:               │
│ - heating_electricity_kw: heating/COP   │
│ - cooling_electricity_kw: cooling/COP   │
│ - total_elec_if_electrified_kw:        │
│   (base + heating_elec + cooling_elec)  │
│                                          │
│ Net Position:                           │
│ - net_demand_kw: demand - generation    │
│ - is_surplus: boolean (generation > demand) │
│ - export_potential_kw: if surplus       │
└─────────────────────────────────────────┘
```

### **1.4 Intelligence & Optimization Nodes**

```markdown
┌─────────────────────────────────────────┐
│ ComplementarityProfile                   │
├─────────────────────────────────────────┤
│ - profile_id: unique identifier         │
│ - building_pair: [building_id_1, building_id_2] │
│ - correlation_coefficient: -1 to 1      │
│ - peak_time_offset_hours: 0-12          │
│ - complementarity_type:                 │
│   day_night/weekday_weekend/seasonal    │
│ - strength: weak/moderate/strong        │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ EnergyCluster                            │
├─────────────────────────────────────────┤
│ - cluster_id: unique identifier         │
│ - lv_network_id: constraint boundary    │
│ - formation_time: when created          │
│ - validity_period: time range active    │
│ - member_buildings: [building_ids]      │
│                                          │
│ Performance Metrics:                    │
│ - baseline_peak_kw: sum of individual peaks │
│ - cluster_peak_kw: actual combined peak │
│ - peak_reduction_percent: improvement   │
│ - self_sufficiency_ratio: internal supply/demand │
│ - export_to_grid_kwh: daily average     │
│ - import_from_grid_kwh: daily average   │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ DeploymentScenario                       │
├─────────────────────────────────────────┤
│ - scenario_id: unique identifier        │
│ - lv_network_id: scope                  │
│ - scenario_type:                        │
│   baseline/solar_max/electrify_all/optimal_mix │
│                                          │
│ Deployments:                            │
│ - solar_installations: [building_ids]   │
│ - battery_installations: [building_ids] │
│ - heat_pump_conversions: [building_ids] │
│ Metrics:                            │
│ - PeakReductionPotential: kW        │
│ - SelfConsumptionIncrease: %        │
│ - PaybackPeriod: years              ││                                          │
│ Impact:                                  │
│ - peak_reduction_kw: vs baseline        │
│ - co2_reduction_tons: annual            │
│ - grid_independence_percent: achieved   │
└─────────────────────────────────────────┘
```




# 1.5 community



# Energy Community Configuration
┌─────────────────────────────────────┐
│ CommunityConfiguration              │
├─────────────────────────────────────┤
│ - ConfigID: unique identifier       │
│ - LVNetworkID: reference            │
│ - Scenario: baseline/solar/electrified/optimal │
│                                     │
│ Asset Distribution:                 │
│ - BuildingsWithSolar: count         │
│ - BuildingsWithBattery: count       │
│ - BuildingsElectrified: count       │
│ - TotalSolarCapacity: kWp           │
│ - TotalBatteryCapacity: kWh         │
│                                     │
│ Performance:                        │
│ - PeakDemand: kW                    │
│ - SelfSufficiency: %                │
│ - GridExport: kWh/day               │
│ - ComplementarityScore: 0-1         │
└─────────────────────────────────────┘


also, we want that for each building sub clusters that they fall, and this clusters can vary, and number of clusters the y chang
also energy share and trade, ....
als, for each cluster the buildings fall, and variation rate, ... and etc 
and other metrics for both clusters and buidlings, ... 




## **2. Relationship Architecture**

```markdown
# Physical Infrastructure Relations
CONNECTED_TO:
  (Building) -[CONNECTED_TO {distance_m, cable_id}]-> (LV_Network)
  
FEEDS_FROM:
  (LV_Network) -[FEEDS_FROM {capacity_kva}]-> (MV_Transformer)
  (MV_Transformer) -[FEEDS_FROM]-> (Substation)

# Asset Relations  
HAS_INSTALLED:
  (Building) -[HAS_INSTALLED {install_date}]-> (SolarSystem)
  (Building) -[HAS_INSTALLED {install_date}]-> (BatterySystem)
  (Building) -[HAS_INSTALLED {install_date}]-> (HeatPumpSystem)

CAN_INSTALL:
  (Building) -[CAN_INSTALL {feasibility_score}]-> (SolarSystem)
  (Building) -[CAN_INSTALL {feasibility_score}]-> (BatterySystem)
  
SHOULD_ELECTRIFY:
  (Building) -[SHOULD_ELECTRIFY {priority, expected_cop}]-> (HeatPumpSystem)

# Temporal Relations
HAS_STATE_AT:
  (Building) -[HAS_STATE_AT]-> (EnergyState) -[DURING]-> (TimeSlot)

FOLLOWS:
  (EnergyState) -[FOLLOWS {duration_min}]-> (EnergyState)

# Complementarity Relations
COMPLEMENTS:
  (Building) -[COMPLEMENTS {score, peak_offset_h}]-> (Building)
  
COULD_SHARE_WITH:
  (Building) -[COULD_SHARE_WITH {potential_kw, distance_m}]-> (Building)

# Clustering Relations
MEMBER_OF:
  (Building) -[MEMBER_OF {join_time, leave_time}]-> (EnergyCluster)
  
TRADES_ENERGY_WITH:
  (Building) -[TRADES_ENERGY_WITH {amount_kwh, price_euro}]-> (Building)

# Scenario Relations
INCLUDED_IN:
  (Building) -[INCLUDED_IN {intervention_type}]-> (DeploymentScenario)
```

## **3. Data Pipeline: Raw Data → KG**



**6. Data Mapping**

```markdown
# From Raw Data to Enhanced KG

## Building Attributes → Enhanced Building Node
PostgreSQL + Energy Labels        →  KG Building Node
───────────────────────────────────────────────────
area, height, age                →  Core attributes
energy_label (A-G)                →  EnergyLabel
age < 1945 + label                →  InsulationLevel (derived)
roof_area + orientation           →  SolarPotential (calculated)
current connection                →  GridConnectionCapacity

## Energy Profiles → Multi-vector States
Simulation Data                   →  KG Energy States
───────────────────────────────────────────────────
electricity_demand_kw             →  ElectricityDemand
heating_demand_kw                 →  HeatingDemand
cooling_demand_kw                 →  CoolingDemand
heating * heat_pump_COP           →  ElectrifiedHeatingDemand
cooling * AC_efficiency           →  ElectrifiedCoolingDemand

## Deployment Analysis → Opportunity Nodes
Analysis Results                  →  KG Opportunities
───────────────────────────────────────────────────










### **3.1 Static Data Processing**

```markdown
# Step 1: Building Characteristics
PostgreSQL buildings_1_deducted → KG Building Nodes
────────────────────────────────────────────────────
ogc_fid                    → building.id
building_function          → building.building_function  
area, height              → building.area, building.height
age_range                 → building.age_range
roof_area                 → building.roof_area
orientation               → building.building_orientation_cardinal


# Step 3: Heating System Inference (NL Statistics)

```

### **3.2 Potential Calculations**

```markdown
# Solar Potential Logic
solar_potential = CALCULATE(
  
  ADJUST BY orientation:
 
potential_capacity_kwp = 
# Battery Readiness Logic
battery_readiness = EVALUATE(

)

recommended_battery_kwh = avg_evening_demand * 3  # 3 hours coverage

# Electrification Feasibility
electrification_feasibility = 
expected_cop = MAP(
 
)
```

### **3.3 Time-Series Integration**

```markdown
# Energy Profiles → Temporal States
For each building, for each timestamp:
────────────────────────────────────
1. Create TimeSlot node (if not exists):
   - timestamp, hour, day_of_week, season
   
2. Create EnergyState node:
   - Link to Building and TimeSlot
   - Store simulated demands (elec, heating, cooling)
   
3. Apply current system assumptions: (these assumptions i have defined for archetypes for subsytem of building i can provisde later)
   
4. Calculate electrification impact:
   electrified_heating = 
   electrified_cooling = 
   total_if_electrified = 

5. Generate solar (if applicable):
   IF has_solar:
     solar_generation = 
     
   
6. Calculate net position:
   net_demand = total_demand - solar_generation
   grid_import = MAX(0, net_demand)
   grid_export = MAX(0, -net_demand)
```

### **3.4 Complementarity Discovery**

```markdown
# Compute Pairwise Complementarity
For each LV_Network:
  For each pair of buildings (b1, b2):
    1. Extract demand profiles over time window
    2. Calculate correlation coefficient
    3. Find peak time offset
    
    IF correlation < -0.3:  # Negative correlation
      CREATE relationship:
        (b1) -[COMPLEMENTS {
          score: 1 - correlation,
          peak_offset: time_difference,
          type: classify_pattern()
        }]-> (b2)
    
    IF b1.has_solar AND b2.evening_peak:
      CREATE relationship:
        (b1) -[COULD_SHARE_WITH {
          potential_kw: min(b1.solar_excess, b2.evening_demand),
          distance: physical_distance
        }]-> (b2)
```




## **7. Scenario Modeling in KG**

```markdown
# Different Scenarios as Graph Layers

## Baseline Scenario (Current State)
- All buildings with existing systems
- Current demand profiles
- No new deployments

## Solar Maximization Scenario
Query: 
Deploy: 
Impact: 
## Electrification Scenario
Query: 
Deploy: Hes
Impact: I

## Optimal Mixed Scenario
GNN Output: 
Deploy: 
Impact: 
```

## **8. Queries for Deployment Planning**

```markdown
# Key Cypher Queries

## 1. Find Best Solar Candidates
```cypher

```

## 2. Find Electrification Priorities
```cypher

```

## 3. Find Complementary Pairs for Battery Sharing
```cypher

```

## 4. Calculate sub clusters Potential
```cypher

```
```














## **4. KG → GNN Feature Extraction**

### **4.1 Node Feature Vector**

```markdown
# Per Building Node Features (Dimension ~50)

Static Features (15 dims):
- area_normalized: area/1000
- height_normalized: height/30  
- age_encoded: [0,0,1,0,0] (one-hot for 5 periods)
- energy_label_ordinal: A=1.0, B=0.85, ... G=0.15
- orientation_encoded: [N,NE,E,SE,S,SW,W,NW] (8 dims)
- roof_suitability: suitable_roof_area/total_roof_area

Current Assets (3 dims):
- has_solar: 0/1
- has_battery: 0/1
- has_heat_pump: 0/1

Potential Scores (4 dims):
- solar_potential_score: 0-1
- battery_readiness_score: 0-1
- electrification_feasibility_score: 0-1
- grid_upgrade_needed: 0/1

Dynamic Features (12 dims):
- current_demand_kw
- morning_avg_demand
- afternoon_avg_demand
- evening_avg_demand
- night_avg_demand
- peak_demand_kw
- valley_demand_kw
- demand_variance
- heating_fraction: heating_demand/total_demand
- cooling_fraction: cooling_demand/total_demand
- solar_generation_noon
- battery_evening_availability

Derived Features (8 dims):
- load_factor: avg_demand/peak_demand
- complementarity_degree: count(COMPLEMENTS edges)
- cluster_compatibility: avg(complementarity_scores)
- solar_self_consumption_potential
- evening_deficit: evening_demand - solar_generation
- morning_surplus: solar_generation - morning_demand
- seasonal_variation_factor
- weekend_difference_ratio

Network Position (8 dims):
- electrical_centrality: position in LV network
- buildings_on_same_transformer: count
- distance_to_transformer_normalized
- available_transformer_capacity_fraction
- neighborhood_solar_penetration: % neighbors with solar
- neighborhood_avg_demand
- is_edge_building: 0/1 (at network boundary)
- has_complementary_neighbor: 0/1
```

### **4.2 Edge Feature Matrix**

```markdown
# Edge Features (8 dims per edge)

Physical Infrastructure:
- edge_type_connected: 1 if CONNECTED_TO else 0
- edge_type_adjacent: 1 if ADJACENT else 0
- electrical_distance_m: normalized
- same_transformer: 0/1

Energy Relationships:
- complementarity_score: -1 to 1
- peak_offset_hours: 0-12 normalized
- potential_sharing_kw: normalized
- correlation_coefficient: -1 to 1
```

### **4.3 Graph Construction for GNN**

```markdown
# Query KG → Build GNN Input

1. Select Scope:
   MATCH (b:Building)-[:CONNECTED_TO]->(lv:LV_Network {id: $lv_id})
   RETURN b, lv

2. Extract Features:
   For each building b:
     X[i] = concatenate(
       b.static_features,
       b.current_assets,
       b.potential_scores,
       b.dynamic_features,
       b.derived_features,
       b.network_position
     )

3. Build Adjacency:
   MATCH (b1:Building)-[r]-(b2:Building)
   WHERE type(r) IN ['CONNECTED_TO', 'ADJACENT', 'COMPLEMENTS']
   edge_index.append([b1.idx, b2.idx])
   edge_attr.append(r.features)

4. Create PyG Data Object:
   data = Data(
     x=node_features,
     edge_index=edge_index,
     edge_attr=edge_features,
     y=target_labels  # If supervised
   )
```

## **5. GNN → KG Feedback Loop**

```markdown
# GNN Outputs Written Back to KG
# How KG Evolves with Interventions

## Clustering Results → KG
For each cluster from GNN:
  CREATE (c:EnergyCluster {
    cluster_id: generated_id,
    formation_time: current_timestamp,
    member_buildings: building_ids,
    peak_reduction: calculated_metric
  })
  
  For each building in cluster:
    CREATE (b)-[MEMBER_OF {confidence: score}]->(c)

## Deployment Recommendations → KG
For each deployment suggestion:
  IF deployment_type = 'solar':
    CREATE (s:SolarSystem {
      status: 'planned',
      building_id: target_building,
      recommended_capacity: gnn_output
    })
    CREATE (b)-[SHOULD_INSTALL {priority: rank}]->(s)

## Discovered Patterns → KG
For each new complementarity pattern:
  CREATE (p:ComplementarityProfile {
    building_pair: [b1_id, b2_id],
    discovered_by: 'GNN',
    confidence: model_confidence
  })
```

## **6. Complete System Flow**

```markdown
# End-to-End Data Flow

1. RAW DATA LAYER
   ├── PostgreSQL: 1.47M buildings with attributes
   ├── Grid Topology: LV/MV networks, transformers
   ├── EnergyPlus Simulation: Hourly demands
   └── Weather Data: For solar simulation

2. STATISTICAL ENRICHMENT
   ├── Assign energy labels based on age/type
   ├── Infer heating systems from NL statistics
   ├── Calculate solar potential from roof/orientation
   └── Estimate electrification feasibility

3. KNOWLEDGE GRAPH CONSTRUCTION
   ├── Infrastructure Layer: Buildings, Networks, Assets
   ├── Temporal Layer: TimeSlots, EnergyStates
   ├── Intelligence Layer: Complementarity, Clusters
   └── Scenario Layer: Deployment options

4. FEATURE ENGINEERING
   ├── Node features: 50+ dimensional vectors
   ├── Edge features: Physical + energy relationships
   ├── Target definition: Peak reduction, self-sufficiency
   └── Constraint encoding: Transformer boundaries

5. GNN PROCESSING
   ├── Message Passing: Aggregate neighborhood info
   ├── Attention Mechanism: Weight important connections
   ├── Temporal Dynamics: LSTM/GRU for time series
   └── Clustering Layer: DiffPool/DMoN for grouping

6. OPTIMIZATION OUTPUTS
   ├── Dynamic Clusters: Time-varying energy communities
   ├── Deployment Priorities: Where to install what
   ├── Energy Sharing: P2P trading recommendations
   └── Performance Metrics: Achieved improvements

7. KG UPDATE & LEARNING
   ├── Store discovered patterns
   ├── Track deployment success
   ├── Update complementarity scores
   └── Refine potential calculations

8. SCENARIO EVALUATION
   ├── Baseline: Current state metrics
   ├── Solar Max: All high-potential roofs
   ├── Electrify Priority: Heat pumps for poor labels
   └── Optimal Mix: GNN-recommended balance
```

## **7. Key Metrics & Evaluation**

```markdown
# Success Metrics in KG

## Community Level (per LV Network)
- Peak Reduction: (baseline_peak - optimized_peak) / baseline_peak
- Self-Sufficiency: internal_generation / total_demand
- Load Factor: average_demand / peak_demand
- Complementarity Index: avg(pairwise_complementarity_scores)
- Grid Independence: 1 - (grid_import / total_consumption)

## Building Level
- Solar Utilization: self_consumed_solar / total_solar_generation
- Flexibility Score: shiftable_load / total_load
- Electrification Readiness: weighted score of label + capacity
- Investment Priority: (potential_benefit * feasibility) / cost

## System Level
- Grid Congestion Relief: reduction in transformer overload hours
- Economic Value: total_cost_savings + avoided_grid_upgrades
- Resilience Score: hours_of_autonomous_operation
```

we need to add more metrics for clusters and buildings to evalute our work, as we dont have real data to validate


---

**This complete KG design provides:**

1. **Full traceability** from raw data through KG to GNN
2. **Statistical logic** for missing data (labels, heating systems)
3. **Clear potential calculations** for solar/battery/electrification
4. **Multi-vector energy** tracking (electricity, heating, cooling)
5. **Temporal dynamics** for clustering evolution
6. **Deployment scenarios** for what-if analysis
7. **Feedback loops** for continuous improvement
8. **Physical constraints** preserved throughout

The system can now answer questions like:
- Which buildings should get solar first?
- What happens if we electrify all poor-label buildings?
- How do clusters change between summer and winter?
- Where does battery storage provide most value?
- What's the optimal mix of interventions for each LV network?




Prepare for GNN
GNN Processing

Message passing incorporates neighborhood
Attention weights learn importance
Pooling creates cluster assignments
Loss function optimizes for complementarity



# Making KG GNN-Ready

## 1. Feature-Rich Nodes
Every node should carry features that GNN can learn from:
- Numerical: area, capacity, demand
- Categorical (encoded): building type, orientation
- Temporal: hour of day, day of week
- Derived: load factor, ramp rate

## 2. Multi-Relational Edges
Different edge types for GNN to distinguish:
- Physical connectivity (hard constraints)
- Temporal proximity (sequential patterns)
- Functional similarity (behavioral patterns)
- Discovered complementarity (learning target)

## 3. Hierarchical Structure
Preserve grid hierarchy for constraint enforcement:
Building → LV → MV → Substation
- Enables hierarchical pooling in GNN
- Enforces transformer boundaries
- Supports multi-scale analysis

## 4. Temporal Dynamics
Two approaches for time in KG:
a) Snapshot Graphs: Separate graph per time slot
b) Temporal Edges: Single graph with time-stamped edges

Recommendation: Hybrid approach
- Core infrastructure as persistent graph
- Energy states as time-indexed properties
- Complementarity as discovered patterns
**Key Additions to Address Your Requirements:**

1. **Energy Labels** - Now a core building attribute affecting deployment priorities
2. **Solar/Battery Status** - Tracks current (has/hasn't) and potential (can/can't install)
3. **Heating/Cooling** - Separate tracking for electrification potential
4. **Multi-stage Deployment** - Can model incremental improvements
5. **Scenario Comparison** - Baseline vs various intervention strategies